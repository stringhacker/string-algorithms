\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{polski}
\usepackage[utf8]{inputenc}

\theoremstyle{definition}
\newtheorem{lemma}{Lemma}[section]

\title{A simple algorithm for Lempel-Ziv factorization}
\author{VM}

\begin{document}

\maketitle

Faktoryzacja Lempel-Ziv'a dla słowa $w$ jest takim rozkładem $u_0 u_1 ... u_k = w$,
że każde $u_i$, za wyjątkiem możliwie ostatniego,
jest albo najdłużsym prefiksem $u_i u_{i + 1} ... u_k$ i występuje jako podsłowo w $u_0 u_1 ... u_i$,
ale nie tylko jako sufiks,
albo jest pojedynczym symbolem, gdy takiego prefiksu nie ma.

Authorzy proponują algorytm pozwalający obliczać faktoryzację w czasie liniowym i pamięci $o(n)$.
Jeszcze poprzedni wynik tych samych autorów osiągał liniowy czas i pamięć,
natomiast różnica pomiędzy dużym $O(n)$ tamtego algorytmu, i małym $o(n)$ dzisiejszego, jest na tyle istotna,
że nowy algorytm został opublikowany.

Algorytm ten, tak jak i poprzedni, korzysta z tablicy Longest Previous Factor.
Aby zrozumieć co to jest, weźmy dowolne słowo $m$.
Jeśli $m$ jest najdłużsym czynnikiem poprzednim,
to musi ono być najdłużsym podsłowem słowa $w[1..i + |m| - 1]$ spośród wszystkich możliwych prefiksów $w[i..n]$.
Jego długość będzie występować w tablicy LPF, na pozycji $i$-tej.

Gdy już posiadamy tablicę LPF, wyznaczanie faktoryzacji nie jest trudne.
Łatwo zauważyć, że ``najdłuższy poprzedni czynnik'', to dokładnie taki czynnik jakiego potrzebujemy do faktoryzacji.
Wystarczy zatem przejść po tablicy LPF zwracając kolejne czynniki,
pomijając przy tym czynniki pośrednie, występujące pomiędzy tymi z faktoryzacji,
oraz zamieniając wszystkie zera na jedynki w tablicy LPF, ponieważ faktoryzacja nie zawiera słów pustych.
\textbf{Algorithm 1} jest implementacją powyższego rozumowania.

\begin{algorithm}
\caption{lempel\_ziv\_factorization}
\begin{algorithmic} 
\REQUIRE LPF, n
\ENSURE LZ
\STATE LZ $\gets [\;]$
\STATE pos $\gets$ 1
\WHILE{pos $\leq$ n}
\STATE push(max(1, LPF[pos]), LZ)
\STATE pos $\gets$ pos + max(1, LPF[pos])
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Pozostaje wyznaczenie LPF. Do tego korzystamy z tablic SA, i LCP --
 z uporządkowanej tablicy sufiksów i tablicy najdłuższych prefiksów między nimi.
Nie będziemy projektować algorytmów do policzenia tych dwóch tablic,
 gdyż wiele takich istnieje.

\pagebreak

W szczególności, do policzenia tablicy SA proponowano jest użyć którykolwiek z poniższych algorytmów:
\begin{enumerate}
\item ``Simple linear work suffix array construction'' autorów J. Kärkkäinen i P. Sanders,
\item ``Linear-time longest-common-prefix computation in suffix arrays and its applications'' autorów T. Kasai, G. Lee, H. Arimura i S. Arikawa,
\item i ``Constructing suffix arrays in linear time'' autorów D.K. Kim, J.S. Sim, H. Park i K.Park,
\end{enumerate}
pamięciowa złożoność których jest usprawniona w pracy ``Space efficient linear time construction of suffix arrays'' autorstwa P. Ko i S. Aluru.

W przypadku LCP, algorytm z pracy ``Two space-saving tricks for linear-time LCP computation'' autora G. Manzini,
 też jest wystarczająco dobry aby nie wpłynąć na złożoność algorytmu LPF.

Zanim przejdziemy do właściwego obliczania LPF, zauważmy kilka własności związanych z jej wartościami.

\begin{lemma}

Wartości tablicy LPF są największymi wpsólnymi prefiksami między elementami tablicy SA.

\begin{proof}

Niech $w$ będzie słowem i $SA_{i}$ będą kolejnymi tablicami prefiksów słowa $w$, uzupełnione o -1 na końcu.
Czyli $SA_{i} = [ SA[k] : SA[k] \leq i ] \cup [-1]$.
Weźmy dowolne $i$, oraz indeks $x$ którego wartość jest maksymalna w tablicy $SA_{i}$,
 czyli $x$ = $\max\limits_{y} \{ x : SA_{i}[x] = y \}$.
Zauważmy, że dla takiego sufiksu $w[x .. n]$, odpowiedni najdłuższy czynnik poprzedni (w sensie definicji LPF)
 jest największym wspólnym prefiksem tego sufiksu z poprzednim, lub z kolejnym sufiksem w tablicy SA.
Jest tak dlatego, że to te sufiksy są najbliżej sufiksu $w[x .. n]$, zatem mają najdłuższy wspólny z nim prefix.

\end{proof}
\end{lemma}

\begin{lemma}

Tablica LPF jest permutacją tablicy LCP.

\begin{proof}

hello there

\end{proof}
\end{lemma}

\end{document}
